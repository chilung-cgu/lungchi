# 1. Binary Search (äºŒåˆ†æœå°‹æ³•)

| LeetCode | é›£åº¦ | æ¨™ç±¤ |
| :--- | :--- | :--- |
| [704. Binary Search](https://leetcode.com/problems/binary-search/) | Easy | Array, Binary Search |

## é¡Œç›®æè¿° (Problem)

çµ¦ä½ ä¸€å€‹ **å·²æ’åº** çš„æ•´æ•¸é™£åˆ— `nums`ï¼ˆå‡åºï¼‰ï¼Œä»¥åŠä¸€å€‹ç›®æ¨™å€¼ `target`ã€‚
è«‹ä½ æ‰¾å‡º `target` åœ¨é™£åˆ—ä¸­çš„ç´¢å¼• (Index)ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œå›å‚³ `-1`ã€‚

### ä¾‹å­ (Examples)
```cpp
Example 1:
Input: nums = [-1, 0, 3, 5, 9, 12], target = 9
Output: 4
// nums[4] == 9

Example 2:
Input: nums = [-1, 0, 3, 5, 9, 12], target = 2
Output: -1
// 2 ä¸åœ¨é™£åˆ—è£¡
```

---

## ğŸ§  æ€è€ƒæ¨¡å¼ (Thinking Process)

### ç‚ºä»€éº¼èƒ½ç”¨ Binary Searchï¼Ÿ
**å‰ææ¢ä»¶ï¼šè³‡æ–™å¿…é ˆå·²ç¶“æ’åºéã€‚**

å› ç‚ºè³‡æ–™æœ‰åºï¼Œæˆ‘å€‘æ¯æ¬¡çŒœã€Œä¸­é–“ã€çš„æ•¸å­—ï¼Œå°±èƒ½ä¸€æ¬¡æ’é™¤ä¸€åŠçš„å¯èƒ½æ€§ã€‚
*   å¦‚æœçŒœçš„å¤ªå° -> ç­”æ¡ˆåœ¨å³é‚Šé‚£åŠ -> å¿½ç•¥å·¦é‚Šã€‚
*   å¦‚æœçŒœçš„å¤ªå¤§ -> ç­”æ¡ˆåœ¨å·¦é‚Šé‚£åŠ -> å¿½ç•¥å³é‚Šã€‚

### æ¼”ç®—æ³•æµç¨‹
1.  è¨­å®šæœå°‹ç¯„åœï¼š`Left = 0`ï¼Œ`Right = len(nums) - 1`ã€‚
2.  ç•¶ `Left <= Right` (ç¯„åœé‚„æœ‰æ•ˆ)ï¼š
    *   ç®—å‡º `Mid`ã€‚
    *   å¦‚æœ `nums[Mid] == target` -> æ‰¾åˆ°äº†ï¼å›å‚³ `Mid`ã€‚
    *   å¦‚æœ `nums[Mid] < target` -> ç›®æ¨™åœ¨å³é‚Š -> `Left = Mid + 1`ã€‚
    *   å¦‚æœ `nums[Mid] > target` -> ç›®æ¨™åœ¨å·¦é‚Š -> `Right = Mid - 1`ã€‚
3.  è‹¥è¿´åœˆçµæŸé‚„æ²’æ‰¾åˆ° -> å›å‚³ `-1`ã€‚

---

## ğŸ“ å¾®æ­¥é©Ÿè¨ˆç•« (Micro-Steps)

1.  **é‚Šç•Œåˆå§‹åŒ–ï¼š** `L = 0`, `R = nums.size() - 1`ã€‚
2.  **ä¸»è¿´åœˆ `while (L <= R)`ï¼š**
    *   è¨ˆç®— `M = L + (R - L) / 2`ã€‚(é˜²æ­¢æº¢ä½)
    *   æ¯”å° `nums[M]` èˆ‡ `target`ã€‚
    *   æ ¹æ“šçµæœèª¿æ•´ `L` æˆ– `R`ã€‚
3.  **å›å‚³ `-1`ï¼š** è‹¥è¿´åœˆçµæŸé‚„æ²’å›å‚³ã€‚

---

## ğŸ’» å¯¦ä½œç¨‹å¼ç¢¼ (C++)

```cpp
#include <vector>

class Solution {
public:
    int search(std::vector<int>& nums, int target) {
        int L = 0;
        int R = nums.size() - 1;

        while (L <= R) {
            // è¨ˆç®—ä¸­é» (é˜²æº¢ä½å¯«æ³•)
            int M = L + (R - L) / 2;

            if (nums[M] == target) {
                return M; // æ‰¾åˆ°äº†ï¼
            } else if (nums[M] < target) {
                L = M + 1; // ç›®æ¨™åœ¨å³åŠé‚Š
            } else { // nums[M] > target
                R = M - 1; // ç›®æ¨™åœ¨å·¦åŠé‚Š
            }
        }

        return -1; // æ²’æ‰¾åˆ°
    }
};
```

### ç‚ºä»€éº¼ç”¨ `L + (R - L) / 2` è€Œä¸æ˜¯ `(L + R) / 2`ï¼Ÿ
*   ç•¶ `L` å’Œ `R` éƒ½æ˜¯å¾ˆå¤§çš„æ­£æ•´æ•¸æ™‚ï¼Œ`L + R` å¯èƒ½æœƒ **æ•´æ•¸æº¢ä½ (Integer Overflow)**ã€‚
*   `L + (R - L) / 2` ä¿è­‰ä¸æœƒæº¢ä½ï¼Œé€™æ˜¯é¢è©¦å®˜å¾ˆæ„›å•çš„ç´°ç¯€ã€‚

### è¤‡é›œåº¦åˆ†æ
*   **æ™‚é–“è¤‡é›œåº¦ï¼š$O(\log n)$** - æ¯æ¬¡ç åŠã€‚
*   **ç©ºé–“è¤‡é›œåº¦ï¼š$O(1)$** - åªç”¨äº†å¹¾å€‹è®Šæ•¸ã€‚

---

## ğŸ§ª è‡ªæˆ‘æª¢æ¸¬
*   [ ] å¦‚æœé™£åˆ—æ˜¯ç©ºçš„ `[]`ï¼Œæœƒæ€æ¨£ï¼Ÿ (R = -1ï¼Œè¿´åœˆ `L <= R` æ˜¯ `0 <= -1` ç‚º falseï¼Œä¸é€²å…¥ï¼Œç›´æ¥å›å‚³ -1ã€‚æ­£ç¢º)ã€‚
*   [ ] ç‚ºä»€éº¼æ˜¯ `L <= R` è€Œä¸æ˜¯ `L < R`ï¼Ÿ (è€ƒæ…®åªå‰©ä¸€å€‹å…ƒç´ çš„æƒ…æ³ `L == R`ï¼Œé‚„æ˜¯è¦æª¢æŸ¥é‚£å€‹å…ƒç´ )ã€‚

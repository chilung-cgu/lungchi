# 0. 回溯法基礎 (Backtracking Basics)

回溯法 (Backtracking) 是一種「暴力搜尋」的優化版本。它的核心概念是：**嘗試 -> 如果不行 -> 撤銷 -> 換一個嘗試**。

---

## 🎯 什麼時候用回溯法？

當題目問你：
*   找出 **所有組合** (Combinations)
*   找出 **所有排列** (Permutations)
*   找出 **所有子集** (Subsets)
*   找出 **所有路徑** (Paths)
*   任何需要「窮舉」的問題

---

## 🌳 回溯法 = 遞迴決策樹

想像你在玩一個迷宮遊戲：
1.  你走到一個岔路口，有三條路可以選。
2.  你選了第一條 (做選擇)。
3.  如果走到死路 (不符合條件)，你往回走 (撤銷選擇)。
4.  然後嘗試第二條路...

這個「做選擇 -> 遞迴探索 -> 撤銷選擇」的過程，就是回溯。

---

## 📜 回溯法模板 (The Template)

```cpp
void backtrack(當前狀態, 選擇列表, 結果集) {
    // 1. Base Case: 達到終止條件 (找到一個解)
    if (滿足終止條件) {
        結果集.push_back(當前狀態);
        return;
    }

    // 2. 遍歷所有可能的選擇
    for (選擇 in 選擇列表) {
        // 2a. 做選擇 (Add)
        當前狀態.push_back(選擇);

        // 2b. 遞迴 (Explore)
        backtrack(新狀態, 新選擇列表, 結果集);

        // 2c. 撤銷選擇 (Remove - 這就是「回溯」！)
        當前狀態.pop_back();
    }
}
```

> **ADHD 心法**：不要試圖在腦中執行整個遞迴樹。專注在「這一層我有哪些選擇」以及「Base Case 是什麼」。

---

## 🧩 經典範例：生成所有子集 (Subsets)

給你 `[1, 2, 3]`，列出所有子集。
```
結果: [[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]
```

決策樹概念：對於每個元素，你有兩個選擇：**選它** 或 **不選它**。

```
                        []
                       /  \
                     /      \
                   [1]       []           (選不選 1?)
                  /  \      /  \
               [1,2] [1]  [2]  []         (選不選 2?)
                / \   / \  / \  / \
            [1,2,3]............           (選不選 3?)
```

準備好了嗎？讓我們來做具體的題目！

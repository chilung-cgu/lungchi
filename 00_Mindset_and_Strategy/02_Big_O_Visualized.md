# 👀 一看就懂的 Big O Visualized

別被這名字嚇到。「Big O」只是一個很裝模作樣的詞，用來問一個簡單的問題：
**「隨著資料變多，這程式會變慢多少？」** (How does it scale?)

對 ADHD 的大腦來說，我們討厭等待。Big O 就是在告訴我們：**誰是快銀 (Quicksilver)，誰是樹懶 (Sloth)。**

---

## 🏎️ 常見的速度分級 (由快到慢)

### 1. $O(1)$ - 瞬間移動 (Constant Time)
不管資料有多少（1 個還是 1 億個），花的時間都一樣。
*   **例子**：陣列索引 (Array Indexing)。
    *   `nums[0]` -> 拿到第一個東西。
    *   不管 `nums` 有多長，拿第一個都是一瞬間。
*   **感覺**：按開關燈。

### 2. $O(\log n)$ - 魔法切半 (Logarithmic Time)
每做一次操作，資料量就少一半。
*   **例子**：二分搜尋法 (Binary Search)。
    *   猜數字遊戲 (1-100)。你猜 50，我說「太小」。
    *   砰！你直接排除了 1-50 這那一半。
    *   雖然沒有 $O(1)$ 快，但比起一個一個找，簡直是魔法。
*   **感覺**：撕電話簿找人。

### 3. $O(n)$ - 乖寶寶排隊 (Linear Time)
資料有多少，就要做幾次。
*   **例子**：for 迴圈遍歷陣列。
    *   要在一堆襪子裡找一隻紅色的，你得一隻一隻拿起來看。
*   **感覺**：閱讀或是數錢。很老實，但資料一多就很累。

### 4. $O(n^2)$ - 災難級慢動作 (Quadratic Time)
巢狀迴圈 (Nested Loops)。每一個資料都要跟其他所有資料互動一次。
*   **例子**：氣泡排序 (Bubble Sort)，或是暴力解 Two Sum。
    *   房間裡有 100 個人，每個人都要跟其他 99 個人握手。
*   **感覺**：塞車。資料稍微多一點點 (比如 10,000 筆)，電腦就會跑到當機。

---

## ⚖️ 空間複雜度 (Space Complexity)

這是在問：**「為了跑這個程式，我需要多佔用多少記憶體？」**

*   **$O(1)$**：我不需要額外的空間，就在原地 (In-place) 解決。
*   **$O(n)$**：我需要一個新袋子，把原本的資料複製一份放進去（比如用 HashMap 存所有的數字）。

> **ADHD 戰略提示**：
> 通常我們為了讓時間變快 (從 $O(n^2)$ 變 $O(n)$)，我們會願意犧牲一點空間 (從 $O(1)$ 變 $O(n)$)。
> 這叫做 **「以空間換取時間」 (Space-Time Tradeoff)**。這是一個非常划算的交易！

---

## 🎯 總結圖表

| 符號 | 暱稱 | 速度 | 評價 |
| :--- | :--- | :--- | :--- |
| **$O(1)$** | 瞬間 | 超神 | 夢寐以求的境界 |
| **$O(\log n)$** | 切半 | 極快 | 非常優秀 (通常是搜尋演算法) |
| **$O(n)$** | 排隊 | 普通 | 大部分最佳解都在這裡 |
| **$O(n \log n)$** | 整理 | 還行 | 排序 (Sorting) 的極限 |
| **$O(n^2)$** | 龜速 | **太慢** | 暴力解，通常是「不合格」的 |
| **$O(2^n)$** | 爆炸 | 毀滅 | 只有遞迴沒寫好才會這樣 |

**記住：我們後面做題目的目標，通常都是把 $O(n^2)$ 的暴力解，優化成 $O(n)$ 或 $O(n \log n)$。**
